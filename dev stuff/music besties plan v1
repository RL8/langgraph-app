# Music Discovery & Engagement App - Technical Implementation Plan

This document outlines the technical implementation plan for the Music Discovery & Engagement App. The architecture emphasizes a clear separation of concerns, leveraging LangGraph for backend orchestration, a PostgreSQL database for structured data, and a dual-pane frontend built with React and CopilotKit for a hybrid user experience.

## 1. Backend Data Curation (LangGraph & Data Management)

This phase focuses on building a robust, curated knowledge base for each artist. This is a background process, triggered when an artist is selected for the first time.

**Objective:** To populate a PostgreSQL database with verified information about artists, albums, songs, and links to reliable external sources.

**Core Tool:** LangGraph orchestrates this workflow, treating each step as a node in a directed graph.

### 1.1. Artist Indexing Workflow

```python
# Conceptual LangGraph Workflow Definition (Pythonic Pseudocode)
from langgraph.graph import StateGraph, END, START
from typing import TypedDict, List, Dict, Any

class IndexingState(TypedDict):
    artist_name: str
    albums_to_process: List[Dict]
    songs_to_process: List[Dict]
    curated_urls: Dict[str, List[Dict]] # {entity_id: [{url, context, type}]}
    current_entity: Dict # {id, type, name}
    search_results: List[Dict] # From Wikipedia or web search

# Define nodes (functions) for the LangGraph
def check_artist_indexed_node(state: IndexingState) -> IndexingState:
    # Query PostgreSQL 'artists' table
    # If artist exists and is_indexed, return state with flag to skip indexing
    # Else, add artist to 'artists' table, set is_indexed=False
    print(f"Checking index status for {state['artist_name']}...")
    # ... database check logic ...
    return state

def search_wikipedia_pages_node(state: IndexingState) -> IndexingState:
    # Use MediaWiki API to find pages for artist, albums, songs
    # Store relevant page URLs in state['search_results']
    print(f"Searching Wikipedia for {state['current_entity']['name']}...")
    # ... MediaWiki API call ...
    return state

def extract_wikipedia_references_node(state: IndexingState) -> IndexingState:
    # For each Wikipedia page in state['search_results'],
    # extract external links from 'References' and 'External links' sections.
    # Filter for reliable music-related domains.
    # Store {url, context_snippet, source_type}
    print(f"Extracting references from Wikipedia for {state['current_entity']['name']}...")
    # ... parsing and filtering logic ...
    return state

def fallback_web_search_node(state: IndexingState) -> IndexingState:
    # If Wikipedia yields insufficient results, use LLM to generate targeted queries
    # Execute via Google Custom Search JSON API
    # LLM analyzes snippets to filter for reliable music content
    print(f"Falling back to web search for {state['current_entity']['name']}...")
    # ... LLM prompt for query generation, API call, LLM for filtering ...
    return state

def store_curated_urls_node(state: IndexingState) -> IndexingState:
    # Store vetted URLs in PostgreSQL 'curated_sources' table
    # Link to artist, album, or song ID
    print(f"Storing curated URLs for {state['current_entity']['name']}...")
    # ... database insert logic ...
    return state

# ... other nodes for iterating through albums/songs ...

# Build the LangGraph
# indexing_workflow = StateGraph(IndexingState)
# indexing_workflow.add_node("check_indexed", check_artist_indexed_node)
# indexing_workflow.add_node("search_wiki", search_wikipedia_pages_node)
# indexing_workflow.add_node("extract_wiki", extract_wikipedia_references_node)
# indexing_workflow.add_node("fallback_search", fallback_web_search_node)
# indexing_workflow.add_node("store_urls", store_curated_urls_node)
# ... add edges and conditional logic ...
# indexing_workflow.set_entry_point("check_indexed")
# indexing_workflow.add_edge("check_indexed", "search_wiki") # Example edge
# ... more complex conditional edges for fallback and iteration ...
# indexing_workflow.add_edge("store_urls", END) # Or loop back to process next item
```

### 1.2. Database Schema (PostgreSQL)

```sql
-- artists table
CREATE TABLE artists (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    is_indexed BOOLEAN DEFAULT FALSE
);

-- albums table
CREATE TABLE albums (
    id SERIAL PRIMARY KEY,
    artist_id INTEGER REFERENCES artists(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    release_year INTEGER,
    total_tracks INTEGER,
    UNIQUE (artist_id, name)
);

-- songs table
CREATE TABLE songs (
    id SERIAL PRIMARY KEY,
    album_id INTEGER REFERENCES albums(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    track_number INTEGER,
    UNIQUE (album_id, name)
);

-- curated_sources table (Polymorphic association to artists, albums, or songs)
CREATE TYPE entity_type_enum AS ENUM ('artist', 'album', 'song');
CREATE TABLE curated_sources (
    id SERIAL PRIMARY KEY,
    entity_id INTEGER NOT NULL,
    entity_type entity_type_enum NOT NULL,
    url TEXT NOT NULL,
    context_snippet TEXT,
    source_type VARCHAR(50), -- e.g., 'review', 'interview', 'official', 'lyrics_analysis'
    UNIQUE (entity_id, entity_type, url)
);

-- user_profiles table
CREATE TABLE user_profiles (
    user_id VARCHAR(255) PRIMARY KEY, -- Or SERIAL if internal user management
    artist_rankings JSONB DEFAULT '{}', -- {artist_id: [album_id1, album_id2, ...]}
    album_rankings JSONB DEFAULT '{}', -- {album_id: ranking_value}
    song_rankings JSONB DEFAULT '{}', -- {song_id: ranking_value}
    album_reviews JSONB DEFAULT '{}', -- {album_id: "review text"}
    song_notes JSONB DEFAULT '{}' -- {song_id: ["note1", "note2"]}
);

-- trivia_leaderboard table
CREATE TABLE trivia_leaderboard (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) REFERENCES user_profiles(user_id) ON DELETE CASCADE,
    album_id INTEGER REFERENCES albums(id) ON DELETE CASCADE,
    score INTEGER NOT NULL,
    questions_answered INTEGER NOT NULL,
    game_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

## 2. Backend Trivia Game Logic (LangGraph)

This LangGraph pipeline manages the interactive trivia game for a specific album, providing educational feedback.

**Objective:** To generate dynamic trivia questions based on curated data, evaluate user answers, and provide educational context.

**Core Tool:** LangGraph orchestrates the game's state and flow.

```python
# Conceptual LangGraph Workflow Definition (Pythonic Pseudocode)
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Dict, Any

class TriviaState(TypedDict):
    user_id: str
    album_id: int
    album_data: Dict # Curated data for the album and its songs
    current_score: int
    questions_asked: List[Dict] # [{question, options, correct_answer, user_answer, feedback}]
    current_question: Dict
    game_status: str # 'active', 'ended'

# Define nodes (functions)
def game_setup_node(state: TriviaState) -> TriviaState:
    # Load all relevant curated data for the specified album from PostgreSQL
    print(f"Setting up trivia for album {state['album_id']}...")
    # ... database query to load album_data ...
    return state

def generate_question_node(state: TriviaState) -> TriviaState:
    # LLM-powered: Craft a trivia question based on album_data
    # e.g., "What famous sample is used in [song_name]?"
    # Generate 4 multiple-choice options (1 correct, 3 plausible incorrect)
    print("Generating new question...")
    # ... LLM prompt for question generation, option generation ...
    question = {"text": "...", "options": [...], "correct": "..."}
    state['current_question'] = question
    return state

def check_answer_and_teach_node(state: TriviaState) -> TriviaState:
    # LLM-powered: Compare user's answer to correct answer
    # Generate concise, educational feedback, referencing curated_sources
    print("Checking answer and preparing feedback...")
    # ... LLM prompt for feedback generation based on correctness and curated data ...
    is_correct = (state['user_choice'] == state['current_question']['correct'])
    feedback = {"text": "...", "source_url": "..."} # LLM-generated feedback
    state['current_score'] += 1 if is_correct else 0
    state['questions_asked'].append({"question": state['current_question'],
                                     "user_answer": state['user_choice'],
                                     "is_correct": is_correct,
                                     "feedback": feedback})
    return state

def update_game_progress_node(state: TriviaState) -> TriviaState:
    # Determine if game continues (e.g., max 10 questions) or ends
    if len(state['questions_asked']) >= 10: # Example limit
        state['game_status'] = 'ended'
    else:
        state['game_status'] = 'active'
    return state

def record_leaderboard_score_node(state: TriviaState) -> TriviaState:
    # Insert/update score in 'trivia_leaderboard' table
    print("Recording score to leaderboard...")
    # ... database insert/update logic ...
    return state

# Build the LangGraph for trivia
# trivia_workflow = StateGraph(TriviaState)
# trivia_workflow.add_node("setup", game_setup_node)
# trivia_workflow.add_node("gen_q", generate_question_node)
# trivia_workflow.add_node("check_ans", check_answer_and_teach_node)
# trivia_workflow.add_node("update_progress", update_game_progress_node)
# trivia_workflow.add_node("record_score", record_leaderboard_score_node)

# trivia_workflow.set_entry_point("setup")
# trivia_workflow.add_edge("setup", "gen_q")
# trivia_workflow.add_edge("gen_q", "check_ans") # User input is implicitly handled between these steps by frontend
# trivia_workflow.add_edge("check_ans", "update_progress")

# trivia_workflow.add_conditional_edges(
#     "update_progress",
#     lambda state: "gen_q" if state['game_status'] == 'active' else "record_score"
# )
# trivia_workflow.add_edge("record_score", END)
```

## 3. Frontend Implementation (React & CopilotKit)

The user interface will provide a seamless experience through a dual-pane design.

### 3.1. Dedicated Dashboard Pane (React)

This pane will be built using React components, providing structured data visualization and traditional form inputs.

**Components:**
- **ArtistOverview:** Displays selected artist, overall album ranking progress (e.g., "3/13 albums ranked").
- **AlbumList:** Iterates through artist's albums, showing name, cover, song ranking progress (e.g., "5/21 songs ranked"), and action buttons ("Rank Album," "Add Review," "View Notes," "Start Trivia").
- **AlbumDetail:** Displays tracklist for a selected album. Each song shows its ranking, user review/notes snippet, and action buttons ("Rank Song," "Add Note," "Write Review").
- **LeaderboardDisplay:** Fetches and displays top scores for selected album trivia games.
- **ReviewForm/NoteInput:** Dedicated forms for detailed text input, submitted via REST API calls to the backend.

**State Management:** Centralized React state management (e.g., React Context, Zustand, or Redux) for UI state and data consistency.

**Data Fetching:** Standard REST API calls to the Python backend for fetching/updating user profile data, discography details, and leaderboard scores.

### 3.2. Copilot Chat Pane (CopilotKit)

This separate chat window integrates AI conversation with dynamic UI elements, powered by CopilotKit.

**CopilotKit Setup:** Initialize CopilotKit in the React app, connecting to a backend endpoint that exposes the LangGraph agents.

#### useMakeActions (for conversational commands)

These actions map natural language commands to backend LangGraph triggers or REST API calls.

```javascript
// Frontend (React with CopilotKit)
import { useMakeActions } from "@copilotkit/react-core";

useMakeActions({
  actions: [
    {
      name: "rankAlbum",
      description: "Ranks a specific album for the user.",
      parameters: [
        { name: "albumTitle", type: "string", description: "Title of the album" },
        { name: "ranking", type: "number", description: "User's ranking (e.g., 1-5)" }
      ],
      handler: async ({ albumTitle, ranking }) => {
        // Call backend API to update user profile
        await fetch('/api/rank-album', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ albumTitle, ranking })
        });
        return `Successfully ranked ${albumTitle} as ${ranking} stars.`;
      },
    },
    {
      name: "startTrivia",
      description: "Starts a trivia game for a given album.",
      parameters: [
        { name: "albumTitle", type: "string", description: "Title of the album to start trivia for" }
      ],
      handler: async ({ albumTitle }) => {
        // Trigger LangGraph trivia workflow via backend API
        const response = await fetch('/api/start-trivia', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ albumTitle })
        });
        const data = await response.json();
        return data.message; // e.g., "Starting trivia for The Blueprint!"
      },
    },
    // ... other actions for adding notes, asking questions about songs/albums ...
  ],
});
```

#### useMakeUIComponent (for embedding UI in chat)

Allows rendering rich, interactive React components directly within the chat stream.

**Trivia Question Display:**

```javascript
// Frontend (React component for trivia question within chat)
import { useCopilotContext } from "@copilotkit/react-core";

const TriviaQuestionComponent = ({ questionText, options }) => {
  const copilot = useCopilotContext();

  const handleOptionClick = (selectedOption) => {
    // Send user's answer back to CopilotKit, which relays to LangGraph
    copilot.sendUserMessage(selectedOption);
  };

  return (
    <div>
      <p>{questionText}</p>
      <div>
        {options.map((option, index) => (
          <button key={index} onClick={() => handleOptionClick(option)}>
            {option}
          </button>
        ))}
      </div>
    </div>
  );
};

// In a CopilotKit action or response, you would render this:
// return <CopilotKit.UIComponent component={TriviaQuestionComponent} props={{ questionText, options }} />;
```

- **Feedback Card:** Displays LLM-generated feedback with a clickable source URL.
- **Progress Card:** A small visual summary of ranking progress.

#### useMakeChatSuggestions (for guiding user flow)

Provides clickable buttons as next steps or prompts within the chat, e.g., "Rank another album," "Play trivia for this album," "Show me reviews."

## 4. Core Technologies & Cross-Cutting Concerns

- **Backend Framework:** Python with FastAPI or Flask for building RESTful API endpoints that serve the frontend and trigger LangGraph workflows.
- **LLM Integration:** LangChain provides the necessary abstractions for connecting to various Large Language Models (LLMs).
- **Model Context Protocol (MCP):** Implemented within LangGraph nodes. This ensures flexible and efficient use of different LLMs based on the specific task (e.g., a smaller, faster LLM for query generation; a more capable LLM for nuanced content analysis or creative question generation). MCP standardizes communication between LLMs and internal tools.
- **API Keys & Security:** All API keys (for LLMs, search services) must be securely managed using environment variables and never hardcoded. Backend APIs should be secured (e.g., OAuth 2.0 for user authentication).
- **Scalability:** Design backend services (especially LangGraph workflows for data curation) for horizontal scalability. Consider message queues for asynchronous tasks.
- **Prompt Engineering:** Iterative refinement of LLM prompts within LangGraph nodes is crucial for high-quality, relevant, and engaging outputs (questions, summaries, feedback).
- **User Experience (UX):** Prioritize a smooth, intuitive, and visually appealing experience. The blend of structured dashboard and conversational chat should feel natural and enhance usability.

This plan provides a clear, technical roadmap for developing the Music Discovery & Engagement App, leveraging modern AI and web development paradigms.